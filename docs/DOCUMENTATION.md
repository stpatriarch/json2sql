# GETTING STARTED

## Բարի գալուստ json2sql հավելվածի Վիկի

Հավելվածների կազմության, թեսթավորման ժամանակ տվյալների բազզա ստեղծելիս, հարմար է  տվյալները պահել json ֆորմատով այն ավելի հարմար է, դյուրակազմ և հեշտությամբ է խմբագրվում, սակայն հետագայում դրա վերափոխումը արդեն հիմնական տվյալերի բազզայի մեջ հանգեցնում է հավելյալ սկրիպտի ստեղծմանը և թեսթավորմանը, դա խլում է բավական ժամանակ։ Այս նպատակին է ծառայում այն գործիքը, այն մասսամբ լուծում է այդ խնդիրը։

Այս պարզագույն գործիքը կոչված է օգնել կատարելու վերափոխում ( convert ) json ֆայլը sql ֆայլի(միայն sqlite շարժիչի պարագայում: Մնացած դեպքերում postgres, mysql այն լռելայն տվյալները կգրանցի տվյլաների բազզայի տրված անվամբ աղյուակում)։ Այն ընդունում է \*.json և վերափոխում այն կամ \*.db (sqlite) ֆայլի կամ տվյալները միանգամից գրանցում սերվերային համանուն աղյուսակում (mysql, postgresql)։

<br>

> **ԿԱՐԵՎՈՐ Է**

 _Ծրագիրը համագործակցում է Python 3.10 կամ ավելի բարձր վերսիաների հետ։ Հավելվածը արդիական է միայն macos, linux, openbsd և այլ unix-like Օպերացիոն Համակարգով աշխատող մեքենաների համար:_

<br>

### json2sql &emsp; | &emsp; ՏԵՂԱԴՐՄԱՆ ԳՈՐԾԸՆԹԱՑԸ։

<br>
<br>

> Ռեպոզիտորիայի պատճենում։

հավելվածի հավաքագրման համար անհրաժեշտ բոլոր ֆայլերը ընդգրկող ռեպոզիտորիան կարելի է պատճենել հետևյալ հրամանով.

`git clone https://github.com/stpatriarch/json2sql.git`

<br>
<br>

> Տվյալների բազզա։

Որպես այդպիսին գործիքը չի օգտվում և կարիգ չունի որևէ տեսակի տվյալների բազզայի, սակայն որոշակի տվյալների բազզաների առկայությունը ենթադրելի է որպեսզի գործիքը կարողանա ավարտին հասցնել իր աշխատանքը։ Եթե ավելի պարզ, **sqlite** շարժիչի պարագայում որևԷ բան տեղադրելու կարիգ չկա այն առկա է փայթոնի լռելայն գրադարանների ցանկում, սակայն ինչ վերաբերում է մնացած շարժիչներին՝ **postgresql, mysql,** ապա այս պարագայում դրանք պետք է տեղադրված լինեն ձեր օպերացիոն համակարգում, բավական չէ միայն համապատասխան գրադարանների առկայությունը, ինչպես որ sqlite-ի պարագայում է։

<br>
<br>

> Անհրաժեշտ գրադարնների տեղադրում։

Անհրաժեշտ գրադարաններն են.

`"psycopg[binary,pool]>=3.2.10"`
`"pymysql>=1.1.2"`

Սակայն գործիքի հավաքագրան ընթացքում դրանք կներբեռնեվեն և կտեղադրվեն ավտոմատ կերպով։

<br>

### json2sql &emsp; | &emsp; ԳՈՐԾԱՐՔՈՒՄ ԵՎ ՇԱՀԱԳՈՐԾՈՒՄ։

Առաջնահերթ պետք է այն տեղադրել, տեղադրման գործընթացին կարելի է ծանոթանալ [այստեղ](INSTALL_AM.MD)

Տեղադրումից հետո կարելի է անցնել շահագործմանը։
Գործիքը նախատեսում է շահագործման մի քանի սցենար կամ տեխնոլոգիաների՝ sqlite, postgresql, mysql կիրառումը։ Սրանից ելնելով դրա շահագործումը կախված է ընտրված տեխնոլոգիայից։ Տեղադրումից հետո խորդուրդ է տրվում համեմատել թե արդյո՞ք ձեր փոխակերպման ենթակա json ֆայլի կազմվածքը առկա է աջակցվողների [ցուցակում](REFERANCES.md):

Հաջորդիվ կարելի է անցնել վերափոխման պրոցեսին.

**sqlite** - այստեղ ամեն բան ավելի քան պարզ է քանի որ գեներացվում է db ֆայլ, դրա շահագործման պրոցեսը կարող է ունենալ այսպիսի տեսք.

```bash
json2sql sqlite -i input_file.json -t sql_table_name
```

**--input, -i** - ջեյսոն ֆայլն է կամ դրա ճանապարհը
**--table, -t** - աղյուակի անունն է, իսկ ֆայլի անունը լռելայն կլինի ջեյսոն ֆայլին համանուն։

Արդյունքում կգեներացվի db ֆայլ։

**postgresql** - այստեղ մի փոքր ամեն բան բարդանում է սակայն ներքոհիշյալ պարամետրերի մեծամասնությունը ունի լռելայն արժեքներ և դրանք փոխելու կարիք չի լինի։ այս պարագայում  պետք է ունենալ արդեն տեղադրված postgresql սերվեր մեքենայի մեջ քանի որ տվյալները գրանցվում է անիջականորեն սերվերային աղյուակի մեջ։

```bash
json2sql postgres -i input_file.json -t sql_table_name
```

**--input, -i** - ջեյսոն ֆայլն է կամ դրա ճանապարհը։
**--host** - հոսթի հասցե, լռելայն localhost։
**--user** - բազզայի օգտատիրոջ անունը, լռելայն postgres։
**--password** - բազզայի գաղտնաբառ, լռելայն postgres։
**--port** - պորտի հասցե, լռելայն 5432։
**--name** - բազզայի աղյուսակի անունը, լռելայն postgres։
**--table, -t** - աղյուակի անունն է։

**mysql** - այստեղ էլ պարագան նույնն է ինչ-որ postgres-ի դեպքում, մեքենայի մեջ պետք է տեղադրված լինի mysql սերվեր նույն պատճառով։

```bash
json2sql mysql -i input_file.json -t sql_table_name
```

**--input, -i** - ջեյսոն ֆայլն է կամ դրա ճանապարհը։
**--host** - հոսթի հասցե, լռելայն localhost։
**--user** - բազզայի օգտատիրոջ անունը, լռելայն root
**--port** - պորտի հասցե, լռելայն 3306։
**--name** - բազզայի աղյուսակի անունը, լռելայն myql։
**--table, -t** - աղյուակի անունն է։

<br>
<br>

# 00 MODULES | JSON

**Json մոդուլը իր մեջ պարունակում է ֆայլի միացում, դրա կառուցվածքի իդենտիֆիկացիա եթե կարիգ կա դրա կառուցվածքի ադապտացիային վերաբերող բոլոր գործիքները։**

* **json_engine** - json ֆայլին միցում, դրա ձևի իդենտիֆիկացիա։
* **json_types** - json ֆայլի ադապտացիա, ռեկուրսիոն նորմալացում։

<br>
<br>

## **json_engine**

<br>

#### **Նպատակը և Առաջադրված խնդիրներ**

<br>

> Ենթամոդուլը իրականացնում է մուտքային json ֆայլին միացումը, ստուգումը արդյո՞ք այն դատարկ չէ, դրա կազմության իդենտիֆիակացիա, եթե այն համապատասխանում է թույլատրված տվյալների տեսակին ապա դրա նորմալիզացիա եթե կա դրա կարիգը և ինիցիալիզացիա այդպիսով նախապատրաստելով այն հետագա վերափոխաման փուլինեին։

<br>

#### **ՆԵՐՄՈՒԾՎԱԾ ԳՐԱԴԱՐԱՆՆԵՐ**

> sys, json

> json2sql.tools, json2sql.modules.json

<br>
<br>

#### **ԴԱՍԵՐ ԵՎ ԴՐԱՆՑ ՆԵՐԿԱՌՈՒՑՎԱԾ ՖՈՒՆԿՑԻԱՆԵՐԸ։**

<br>

**`JsonModify` &emsp; | &emsp; ՋԵՅՍՈՆ ՖԱՅԼԻ ՄՈԴԻՖԻԿՑԻԱ**

Դասը և նրա ներկառուցված ֆունկցիաները կատարում են ենթամոդուլի ամբողջ լոգիկան։

<br>

Եթե դասը ունի ներկառուցված ֆունցիաներ դրանց նկարարգրությունը պետք է ունենա ասպիսի ֆորմատ։

_JsonModify_.**`json_normalize(void)` &emsp; | &emsp; ՋԵՅՍՈՆԻ ՆՈՐՄԱԼԻԶԱՑԻԱ**

Ֆունցկիան ստուգում է ջեյսոն ֆայլի թույլատրելիութունը ներկրված ACCEPTABLE_TYPES շաքի միջոցով, սա իրականցված է կանխարգելեու ֆունկցիայի անկախատեսելի պահվածքը, քանի որ եթե իդենտիֆիակացիա անցած ջեյսոն կառուցվածքը չկա աջակցվածների ցուցակում դրա հետագա աշխատանքը անիմաստ է և գործիքը կավարտի իր աշխատանքը ցուցադրելով սխալի պատճառը։ Հակառակ պարագայում ֆունկցիան կինիցիալիզացնի ֆայլը կատարելով նախապատրաստական աշխատանքներ տվյլա կառուցվածքին համապատասխան ձևով, հետագա վերափոխման համար։

_JsonModify_.**`is_branched(void)` &emsp; | &emsp; ՃՅՈՒՂԵՐԻ ՍՏՈՒԳՈՒՄ**

Ֆունցիան կստուգի ջեյսոնի կառուցվածքը հասկանալու համար արդյո՞ք այն ճյուղավորված է, եթե այո կվերադարձնի **True** այլապես **False։** Ֆունցկիան կատարում է օգնականի դեր _json_normalize_ ֆունկցիայի համար և հաջորդիվ էլ կատարում է նույն դերը։

_JsonModify_.**`define_json_struct(void)` &emsp; | &emsp; ԿԱՌՈՒՑՎԱԾՔԻ ԻԴԵՆՏԻՖԻԿԱՑԻԱ**

Ֆունկցիան կատարում է ջեյսոնի կառուցվածքի նախնական վերլուծություն, տալով նրան հայտնի կոդային անվանումներից մեկը ստացված տվյալենրը փոխանցելով _json_normalize_ ֆունցիային որի հիման վրա վերջինս կախված կառուցվածքից կատարում է նորմալիզացիա

_JsonModify_.**`_connect(void)` &emsp; | &emsp; ԿԱՊԻ ՀԱՍՏԱՏՈՒՄ**

Ֆունկցիան կատարում է ֆայլի հետ կապի հաստատում և եթե չի հանգում որևէ սխալի, ապա վերադարձնում է ջեյսոն օբյեկտ հետագա շահագործման համար, հանգելով որևէ սխալի այն կհանյտնի դրա մասին և կավարտի ծրանգրի աշխատանքը։

<br>
<br>

## **json_types**

<br>

#### **Նպատակը և Առաջադրված խնդիրներ**

<br>

> Ենթամոդուլը իրականացնում է ջեյսոնի վերամշակումը կախված դրա պայմանական կոդային անվանումից, կատրում դրա ստանդարտիզայիա, վերամշակում այն, և վերադարձնում է որպես փայթոն օբյետկ ինիցիալիզացնելով այն։

<br>

#### **ՆԵՐՄՈՒԾՎԱԾ ԳՐԱԴԱՐԱՆՆԵՐ**

> collections

<br>
<br>

#### **ԴԱՍԵՐ ԵՎ ԴՐԱՆՑ ՆԵՐԿԱՌՈՒՑՎԱԾ ՖՈՒՆԿՑԻԱՆԵՐԸ։**

<br>

**`JsonTypeIdentifer` &emsp; | &emsp; ԲԱԶԶԱՅԻՆ ԴԱՍ**

Այն ծառայում է որպես բազզային դաս բոլոր ներքոհիշյալ դասերի համար, պարտադրելով դրանց հետևել ընդհանրական ինտերֆեյսի։

_JsonTypeIdentifer_.**`initialization(void)` &emsp; | &emsp; ԵՐԱՇԽԱՎՈՐԻՉ**

Ֆունցիան չի կատարում ոչ-մի դեր բացի իր գոյությամբ երաշխավորելով որ բոլոր ենթադասերը կունենան իրենց մեջ իրականացրած համանում ֆունկցիա ծրագրի խափանումից խուսափելու համար։

Այս ֆունկցիան հաջորդիվ ֆունկցիաներում կատարում է ինիցիալիզացիայի կամ հայտարարիչի դեր, այսինքն այն վերջնականորեն ինդենտիֆիկացրած տվյալը օժտում է կոդային-պայմանական անվամբ, այդպիսով բնութագրելով կամ դասելով այն կոնկրետ ջեյսոն-կարգի։

_JsonTypeIdentifer_.**`json_standardize(dct: dict, parent_key: str='', sep: str='_' )` &emsp; | &emsp; ՍՏԱՆԴՐԱՏԻԶԱՏՈՐ**

Ֆունկցիան ստուգում է ջեյսոնի կառուցվածքը եթե այն իր հերթին ունի ներկառուցված ճյուղավորումներ որը բարդացնում է այդ տվյալները բազզայի մեջ գրանցելու գործը, ապա այն դա բերում է մեկ ընդանուր ձևի։ Ստանդարտի է բերում ռեկուրսիվ ինքն իրեն կանչելով այնքան ժամ մինչև չստանա տափակ ջեյսոն կառուցվածք։ Մյուս դասերում նույնպես կա ռեալիզացված համանուն ֆունկցիա, սակայն դրանք իրականցված են տարբեր ձևով, տարբեր ջեյսոն կառուցվածքների համար։ Չի ռեալիզաված մեկ ֆունկցիայում դրա լակոնիկ և որքան թույլ է տալիս խնդրիը պարզ կառուցվածք ապահովելու համար։

_JsonTypeIndentifer_.**`calibrate(input: dict) -> dict:` &emsp; | &emsp; ԿԱՐԳԱԲԵՐԻՉ**

Ֆունկցիան կատարում է բավական պեցեֆիկ դեր, հայտնի է որ, sqlite շարժիչը չունի ցուցակին(list, array) համապատասխանող տվյալի տեսակ, հետևաբար այն անկարող է պահապնել նմանատիպ տվյալ բազզայում, այս ֆունկցիան փնտրում է ստուգելու համար թե արդյո՞ք տվյալի արժեքներում չկա այդպիսի տվյալ, եթե գտնում է այնդպիսին այն դրա մեջի արժեքները փոսեվորում է կամ տեղադրում է տողային(str, string) արժեքի մեջ և վերադարձնում է արդեն մոդիֆիկացրած կամ ուղղած բառարանը։

**Հաջորդիվ ժառանգ դասերի և դրանց ներկառուցյալ ֆունկցիաների նկարագրության կարիգը չկա քանզի դրանք կրկնում են արդեն կնարարգրված ֆունկցիաներին, տեղ-տեղ աննշան ձևով փոխելով դրանց պահվածքը այդպիսով չմցնելով դրանց մեջ էական կամ զգալի փոփոխություն որը հիշատակման կամ պարզաբանման կարիգ ունենա**

<br>
<br>

# 01 MODULES | SQL

<br>

**SQL կապի ստեղծում, հարցումների կազմում, աղյուակների ստեղծում, տվյալների մուտքգրում բազզա։**

<br>

## **sql_engine**

#### **Նպատակը և Առաջադրված խնդիրներ**

Կկատարի կապի հաստատման, տվյաների նախապատրաստման և դրանց մուտքագրման աշխատանքները։

---

#### **ԴԱՍԵՐ ԵՎ ԴՐԱՆՑ ՆԵՐԿԱՌՈՒՑՎԱԾ ՖՈՒՆԿՑԻԱՆԵՐԸ։**

<br>

 **`SqlEngine` &emsp; | &emsp; ԲԱԶԶԱՅԻՆ ԴԱՍ**

Կազմակերպում է մոդուլի նշանակության հիմնական ֆունկցիոնալ մասերը։

_SqlEngine_.**`connection(void) -> None:` &emsp; | &emsp; ԿԱՊԻ ՀԱՍՏԱՏՄԱՆ ՏԵՂԱՊԱՀ**

params: None

returns: None

Տեղապահ ֆունկցիա որը երաշխավորում է ժառանգ ֆունկցիերում նման ֆունկցիայի առկայությունը, ընդհանուր ինտերֆեյս ապահովելու նպատակով։

<br>

_SqlEngine_.**`create(void) -> None:` &emsp; | &emsp; ԱՂՅՈՒԱԿ ՁԵՎԱՆՄՈՒՇԻ ՍՏԵՂԾՈՒՄ**

params: None

returns: connection object

Այն կստեղծի աղյուսակների գրանցման գրանցման ձև sql տվյալների տեսակներով կախված ընտրված շարժիչից և դրանք կգրանցի բազզայի մեջ ընտրված շարժիչի  (sqlite, postgresql, mysql) իրականցված connection ֆունկցիայի օգնությամբ։

<br>

_SqlEngine_.**`insert(void) -> None:` &emsp; | &emsp; ՏՎՅԱԼՆԵՐԻ ԳՐԱՆՑՈՒՄ ԿԱՄ ԿՈՆՎԵՐՏԱՑԻՈՆ ՊՐՈՑԵՍՍ**

params: None

returns: connection object

ֆունկցիան կնախապատրաստի հիմնական հարցման ձևերը տվյալները գրանցելու համար, դրա իրենից ենթադրում է բոլոր բանալիների ստեղծումը կախված մուտքագրման ենթակա տվյալներից, դրանց համար տեղապահների ստեղծումը և տվյալների գրանցումը բազզա։

<br>

_SqlEngine_.**`prepare_json_by_group(void) -> list:` &emsp; | &emsp; ՏՎՅԱԼՆԵՐԻ ԳՐԱՆՑՄԱՆ ՆԱԽԱՊԱՏՐԱՍՏՈՒԹՅՈՒՆ**

params: None

returns: list

Ֆունկցիան ստուգում է թե ինչ պայմանական դասի է պատկանում տվյալը, կախված դրանից նախապատրաստում է այն դեպի բազզա մուտքագրմանը, տվյալները ադապտացնելով մուտքագրամանը և ցուցմունքներ պատրաստում վերոհիշվյալ insert ֆունկցիայի համար թե ինչպես և ինչի ներքո է պետք մուտքագրել տվյալների յուրաքանչյուր բաղադրիչը։

<br>

 **`SqliteEngine -> PostgresEngine -> MysqlEngine` &emsp; | &emsp; ԺԱՌԱՆԳ ԴԱՍԵՐ**

params: Any

returns: None

Այստեղ ներակյացված են երեք շարժիչ-դասերը որոնք հանդիսանում են ժառանգ վերոհիշյալ SqlEngine դասին։ Դրանց առանձին նկարագրելու անհրաժեշտություն չկա, քանի նրանցում միակ որը իրականացված է դա `connection` ֆունկցիան է որն էլ իրենից ներկայացնում է կապի հաստատման եղանական յուրաքանչյուր շարժիչի համար։

Միայն հարկ է նշել որ յուրաքանչյուրում իրականացված է գլոբալ փոփոխական `engine` շարժիչին համապատասխան անունով ընդանուր ինտերֆեյսը պահպանելու  համար և ստուգելու դրա ճշմարտություն  լինելըև `init` ֆունկցիան որը ընդունում է պարամետրեր յուրաքանչյուր շարժիչին և դրա ստանդարտներին համապատասխան ձևով։

<br>
